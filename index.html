  <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flag Survival Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #0b0f1a;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// Arena
let center={x:0,y:0}, radius=0;
let gapAngle = 0;
const GAP_SIZE = Math.PI/5;

function updateArena(){
  center.x = canvas.width/2;
  center.y = canvas.height/2;
  radius = Math.min(canvas.width,canvas.height)*0.35;
}

// Flags (balls)
const flags=[];
const TOTAL=40;

function spawnFlags(){
  flags.length=0;
  for(let i=0;i<TOTAL;i++){
    const a=Math.random()*Math.PI*2;
    const r=Math.random()*radius*0.8;
    flags.push({
      x:center.x+Math.cos(a)*r,
      y:center.y+Math.sin(a)*r,
      vx:(Math.random()-0.5)*4,
      vy:(Math.random()-0.5)*4,
      size:7,
      color:`hsl(${Math.random()*360},80%,60%)`,
      inside:true
    });
  }
}
updateArena();
spawnFlags();

// Physics
function update(){
  gapAngle += 0.008;

  for(const f of flags){
    f.vy += 0.15; // gravity

    f.x += f.vx;
    f.y += f.vy;

    // screen walls
    if(f.x<f.size){f.x=f.size;f.vx*=-0.7;}
    if(f.x>canvas.width-f.size){f.x=canvas.width-f.size;f.vx*=-0.7;}
    if(f.y>canvas.height-f.size){
      f.y=canvas.height-f.size;
      f.vx*=0.9;
      f.vy=0;
    }

    const dx=f.x-center.x;
    const dy=f.y-center.y;
    const dist=Math.hypot(dx,dy);

    if(dist<radius){
      f.inside=true;
    }

    if(dist+f.size>radius){
      const ang=Math.atan2(dy,dx);
      let diff=(ang-gapAngle+Math.PI*3)%(Math.PI*2);

      if(diff>GAP_SIZE){
        const nx=dx/dist, ny=dy/dist;
        const dot=f.vx*nx+f.vy*ny;
        f.vx-=2*dot*nx;
        f.vy-=2*dot*ny;
        f.x=center.x+nx*(radius-f.size);
        f.y=center.y+ny*(radius-f.size);
      }else{
        f.inside=false; // escaped
      }
    }
  }
}

// Draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // arena with gap
  ctx.lineWidth=7;
  ctx.strokeStyle="#4fc3ff";
  ctx.beginPath();
  ctx.arc(center.x,center.y,radius,gapAngle+GAP_SIZE,gapAngle+Math.PI*2);
  ctx.stroke();

  for(const f of flags){
    ctx.fillStyle=f.color;
    ctx.beginPath();
    ctx.arc(f.x,f.y,f.size,0,Math.PI*2);
    ctx.fill();
  }
}

// Loop
function loop(){
  updateArena();
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

</script>

</body>
</html>
